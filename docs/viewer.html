<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Viewer</title>
    <meta name="theme-color" content="#0b0d10" media="(prefers-color-scheme: dark)">
    <meta name="theme-color" content="#f8f9fa" media="(prefers-color-scheme: light)">
    <style>
      /* Bootstrap-like theme variables and primitives */
      :root {
        --bg:#0b0d10;          /* body bg (dark) */
        --fg:#e6e9ef;          /* body color (dark) */
        --muted:#9aa4b2;       /* muted text */
        --bar:#121417;         /* navbar bg */
        --border:#20242a;      /* borders */
        --accent:#6ea8fe;      /* primary */
        --radius: .375rem;     /* bs border-radius */
        --shadow-focus: 0 0 0 .25rem rgba(110,168,254,.25);
      }
      html[data-theme="light"] {
        --bg:#f8f9fa;
        --fg:#0b0d10;
        --muted:#5c6673;
        --bar:#ffffff;
        --border:#e5e7eb;
        --accent:#0d6efd;
        --shadow-focus: 0 0 0 .25rem rgba(13,110,253,.25);
      }
      html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); color-scheme: light dark; font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif; }

      /* Navbar */
      .bar { display:flex; align-items:center; gap:12px; padding:10px 12px; background:var(--bar); border-bottom:1px solid var(--border); position:sticky; top:0; z-index:10; }
      .brand { font-weight:600; white-space:nowrap; }
      .src { flex:1; max-width:min(60vw, 900px); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; opacity:.9; }
      .controls { display:flex; align-items:center; gap:8px; }

      /* Buttons (outline-secondary-ish) */
      .btn { display:inline-block; padding:.375rem .75rem; border:1px solid var(--border); background:transparent; color:var(--fg); text-decoration:none; border-radius:var(--radius); cursor:pointer; transition: background-color .15s ease, color .15s ease, border-color .15s ease, box-shadow .15s ease; }
      .btn:hover { background:rgba(110,168,254,.08); border-color:color-mix(in oklab, var(--border), var(--accent) 25%); }
      .btn:active { background:rgba(110,168,254,.16); }
      .btn:focus-visible { outline:0; box-shadow: var(--shadow-focus); }
      .btn.disabled, .btn[aria-disabled="true"] { opacity:.5; pointer-events:none; }

      /* Page input mimics form-control */
      .page { display:inline-flex; align-items:center; gap:6px; }
      .page input { width:76px; padding:.375rem .5rem; border:1px solid var(--border); border-radius:var(--radius); background:transparent; color:var(--fg); }
      .page input:focus-visible { outline:0; box-shadow: var(--shadow-focus); border-color: color-mix(in oklab, var(--border), var(--accent) 35%); }
      .page input::-webkit-outer-spin-button,
      .page input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
      .page input[type=number] { -moz-appearance: textfield; }

      /* Canvas container */
      #container { display:flex; justify-content:center; padding:10px; background:var(--bg); }
      #canvas { max-width:100%; width:100%; height:auto; background: rgba(0,0,0,.2); border-radius:var(--radius); }
      .msg { padding:16px; color:var(--muted); }
      a { color: var(--accent); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js" referrerpolicy="no-referrer"></script>
    <script>
      // Theme: use dark by default; respect user/device if specified
      (function setTheme() {
        const root = document.documentElement;
        const mqDark = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
        const mqLight = window.matchMedia ? window.matchMedia('(prefers-color-scheme: light)') : null;
        // Default to dark when no explicit preference
        let theme = 'dark';
        if (mqDark && mqDark.matches) theme = 'dark';
        else if (mqLight && mqLight.matches) theme = 'light';
        root.setAttribute('data-theme', theme);
        try {
          mqDark && mqDark.addEventListener('change', e => {
            root.setAttribute('data-theme', e.matches ? 'dark' : (mqLight && mqLight.matches ? 'light' : 'dark'));
          });
          mqLight && mqLight.addEventListener('change', e => {
            root.setAttribute('data-theme', e.matches ? 'light' : (mqDark && mqDark.matches ? 'dark' : 'dark'));
          });
        } catch (_) {}
      })();
      // Will set the worker src after pdfjsLib is available
      let currentRenderTask = null;
      let resizeTimer = null;

      function getParams() {
        const url = new URL(window.location.href);
        const file = url.searchParams.get('file');
        // Support both #page= and ?page=
        let page = parseInt(url.searchParams.get('page') || '', 10);
        if (!Number.isFinite(page)) {
          const m = (url.hash || '').match(/page=(\d+)/);
          if (m) page = parseInt(m[1], 10);
        }
        // Optional section from query or hash
        let section = url.searchParams.get('section') || '';
        if (!section) {
          const sm = (url.hash || '').match(/section=([^&#]+)/);
          if (sm) section = decodeURIComponent(sm[1]);
        }
        // Optional printed page label (for single-page slices)
        let printed = parseInt(url.searchParams.get('printed') || '', 10);
        if (!Number.isFinite(printed)) {
          const pm = (url.hash || '').match(/printed=(\d+)/);
          if (pm) printed = parseInt(pm[1], 10);
        }
        return { file, page: Number.isFinite(page) ? page : 1, section, printed: Number.isFinite(printed) ? printed : null };
      }


      function setNavAnchors({ file, section, displayPage, total, printed, isSlice, sliceBase, maxPages, firstPage }) {
        try {
          const leftEl = document.getElementById('left');
          const rightEl = document.getElementById('right');
          if (!leftEl || !rightEl) return;
          const base = location.origin + location.pathname; // viewer.html
          function hrefFor(n) {
            if (isSlice && sliceBase) {
              const targetFile = `${sliceBase}p${n}.pdf`;
              const q = '?file=' + encodeURIComponent(targetFile);
              const h = '#page=1&printed=' + n + (section ? ('&section=' + encodeURIComponent(section)) : '');
              return base + q + h;
            }
            const q = '?file=' + encodeURIComponent(file);
            const hParts = ['page=' + n];
            if (section) hParts.push('section=' + encodeURIComponent(section));
            return base + q + '#' + hParts.join('&');
          }

          const start = Number.isFinite(firstPage) ? firstPage : 1;
          const current = Math.max(start, parseInt(displayPage, 10) || start);
          const prev = Math.max(start, current - 1);
          const next = current + 1;

          // Set left anchor
          leftEl.href = hrefFor(prev);
          const atStart = current <= start;
          leftEl.classList.toggle('disabled', atStart);
          leftEl.setAttribute('aria-disabled', atStart ? 'true' : 'false');

          // Set right anchor
          let atEnd = false;
          if (!isSlice && Number.isFinite(total)) atEnd = current >= total;
          if (isSlice && Number.isFinite(maxPages)) atEnd = current >= maxPages;
          rightEl.href = hrefFor(next);
          rightEl.classList.toggle('disabled', atEnd);
          rightEl.setAttribute('aria-disabled', atEnd ? 'true' : 'false');
        } catch (_) {}
      }

      // --- JSON with comments support (JSONC) ---
      function parseJsonC(text) {
        if (typeof text !== 'string') return null;
        // Remove UTF-8 BOM
        if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
        // Strip /* block */ comments
        text = text.replace(/\/\*[\s\S]*?\*\//g, '');
        // Strip // line comments
        text = text.replace(/(^|\s)\/\/.*$/gm, (m) => (m.startsWith('//') ? '' : m.replace(/\/\/.*$/, '')));
        // Remove trailing commas in objects/arrays
        text = text.replace(/,(\s*[}\]])/g, '$1');
        return JSON.parse(text);
      }

      async function fetchConfigJson(url) {
        try {
          const resp = await fetch(url, { cache: 'no-store' });
          if (!resp.ok) return null;
          const txt = await resp.text();
          return parseJsonC(txt);
        } catch (_) { return null; }
      }

      async function render({ file, page, section, printed }) {
        const msg = document.getElementById('msg');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        if (!file) {
          msg.innerHTML = 'Missing \'file\' query param. Example: <code>viewer.html?file=' +
            encodeURIComponent('https://raw.githubusercontent.com/owner/repo/branch/path/to.pdf') + '#page=2</code>';
          return;
        }
        // Expect modern file paths; no legacy remapping

        // Auto-slice handling and slice config
        let usePrintedForDisplay = false;
        let isSliceContext = false;
        let sliceBase = '';
        let sliceConfig = null;
        let fileConfig = null; // per-file (non-slice) sidecar config
        try {
          const dec = decodeURIComponent(file);
          const RULEBOOK_FULL = 'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/Rule Book_2P V9/Rule Book_2P V9.pdf';
          // New slice base (folder holds slices + config.json)
          const RB_SLICE_BASE = 'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/Rule Book_2P V9/';
          const isFull = (dec === RULEBOOK_FULL);
          const isRBslice = dec.startsWith(RB_SLICE_BASE);
          if (isFull || isRBslice) {
            // Determine printed page:
            // - If coming from full file: treat #page as printed page.
            // - If coming from slice: parse p{N}.pdf if printed not supplied.
            let printedPage = printed;
            if (!Number.isFinite(printedPage)) {
              if (isRBslice) {
                // Try config pattern first
                try {
                  const cfgUrl = new URL('config.json', RB_SLICE_BASE).toString();
                  const cfg = await fetchConfigJson(cfgUrl);
                  if (cfg) {
                    const re = regexFromPattern(cfg.filename_pattern || 'p{n}.pdf');
                    const m = dec.match(re);
                    if (m) printedPage = parseInt(m[1], 10);
                  }
                } catch (_) {}
                if (!Number.isFinite(printedPage)) {
                  const m2 = dec.match(/\/p(\d+)\.pdf$/);
                  if (m2) printedPage = parseInt(m2[1], 10);
                }
              }
            }
            if (!Number.isFinite(printedPage)) {
              printedPage = Number.isFinite(page) ? page : 1;
            }
            // If config exists, honor filename_pattern
            let targetName = 'p' + printedPage + '.pdf';
            try {
              const cfgUrl = new URL('config.json', RB_SLICE_BASE).toString();
              const cfg = await fetchConfigJson(cfgUrl);
              if (cfg) {
                targetName = fileNameFromPattern(cfg.filename_pattern || 'p{n}.pdf', printedPage);
              }
            } catch (_) {}
            file = RB_SLICE_BASE + targetName;
            page = 1; // slices are single-page
            printed = printedPage;
            usePrintedForDisplay = true;
            isSliceContext = true;
            sliceBase = RB_SLICE_BASE;
          }
        } catch (_) { /* ignore */ }

        // If current file is any slice under /files/by_page/slices/, derive sliceBase generically
        try {
          const u = new URL(file);
          const path = decodeURIComponent(u.pathname);
          if (path.includes('/files/by_page/slices/') || path.includes('/files/Rule Book_2P V9/')) {
            const base = u.toString().replace(/[^/]+$/, ''); // keep trailing /
            sliceBase = base;
            isSliceContext = true;
          }
        } catch (_) {}

        // Try to load optional slice config (config.json) from the slice folder
        let sliceMaxPages = null;
        let sliceFirstPage = 1;
        let slicePageLabel = 'printed';
        let sliceTitle = '';
        let sliceFilenamePattern = 'p{n}.pdf';
        let sliceLinkMode = 'slice';
        if (isSliceContext && sliceBase) {
          const cfgUrl = new URL('config.json', sliceBase).toString();
          const cfg = await fetchConfigJson(cfgUrl);
          if (cfg) {
            sliceConfig = cfg;
            if (Number.isFinite(cfg.max_pages)) sliceMaxPages = cfg.max_pages;
            if (Number.isFinite(cfg.first_page)) sliceFirstPage = cfg.first_page;
            if (typeof cfg.page_label === 'string') slicePageLabel = cfg.page_label;
            if (typeof cfg.title === 'string') sliceTitle = cfg.title;
            if (typeof cfg.filename_pattern === 'string') sliceFilenamePattern = cfg.filename_pattern;
            if (typeof cfg.link_mode === 'string') sliceLinkMode = cfg.link_mode;
          }
        }

        // For non-slice single PDFs, look for a sidecar config next to the file: <filename>.config.json
        if (!isSliceContext && file) {
          try {
            const u = new URL(file);
            const name = u.pathname.split('/').pop() || '';
            const sidecar = new URL(encodeURIComponent(decodeURIComponent(name)) + '.config.json', file).toString();
            // Above can double-encode; safer rebuild: origin + dir + filename + '.config.json'
            const dir = u.toString().replace(/[^/]+$/, '');
            const decodedName = decodeURIComponent(name);
            const sidecarUrl = dir + encodeURIComponent(decodedName + '.config.json');
            const cfg = await fetchConfigJson(sidecarUrl);
            if (cfg) fileConfig = cfg;
          } catch (_) {}
        }
        msg.textContent = 'Loading…';
        try {
          const pdf = await pdfjsLib.getDocument({ url: file, withCredentials: false }).promise;
          const total = pdf.numPages;

          // Try to align by printed page labels if available
          let target = Math.min(Math.max(1, page), total);
          try {
            const labels = await pdf.getPageLabels();
            if (labels && labels.length === total) {
              const desired = String(page);
              // Match numeric labels, ignoring non-digits (e.g., roman numerals are skipped)
              const desiredNum = parseInt(desired, 10);
              if (Number.isFinite(desiredNum)) {
                for (let i = 0; i < labels.length; i++) {
                  const num = parseInt(String(labels[i]).replace(/[^0-9]/g, ''), 10);
                  if (num === desiredNum) { target = i + 1; break; }
                }
              }
              // If non-slice config requests printed label display, use that for UI
              if (!isSliceContext && fileConfig && fileConfig.page_label === 'printed') {
                // Prefer the requested printed page value if provided; otherwise use label of target
                const labelAtTarget = parseInt(String(labels[target-1]).replace(/[^0-9]/g, ''), 10);
                if (Number.isFinite(labelAtTarget)) {
                  printed = labelAtTarget; // reuse printed variable for display purposes
                  usePrintedForDisplay = true;
                }
              }
            }
          } catch (_) { /* ignore label lookup issues */ }

          const p = await pdf.getPage(target);
          const viewport = p.getViewport({ scale: 1 });

          // Fit to device width with some margin
          const dpiScale = window.devicePixelRatio || 1;
          const targetWidthCSS = Math.min(window.innerWidth - 20, 1200);
          const scale = targetWidthCSS / viewport.width;
          const v2 = p.getViewport({ scale });

          canvas.width = Math.floor(v2.width * dpiScale);
          canvas.height = Math.floor(v2.height * dpiScale);
          canvas.style.width = Math.floor(v2.width) + 'px';
          canvas.style.height = Math.floor(v2.height) + 'px';

          // Cancel any in-flight render on the same canvas
          if (currentRenderTask && typeof currentRenderTask.cancel === 'function') {
            try { currentRenderTask.cancel(); } catch (_) {}
          }
          currentRenderTask = p.render({ canvasContext: ctx, viewport: p.getViewport({ scale: scale * dpiScale }) });
          try { await currentRenderTask.promise; } catch (_) { /* cancelled */ }
          msg.textContent = '';

          // Update controls
          let displayPage = usePrintedForDisplay && printed ? printed : target;
          // Respect page_label option for slices
          if (isSliceContext && slicePageLabel === 'index') displayPage = 1;
          const displayTotal = (isSliceContext && Number.isFinite(sliceMaxPages)) ? sliceMaxPages : (isSliceContext ? 82 : total);
          const pageInputEl = document.getElementById('page');
          pageInputEl.value = displayPage;
          if (isSliceContext && Number.isFinite(sliceMaxPages)) pageInputEl.setAttribute('max', String(sliceMaxPages));
          else if (isSliceContext) pageInputEl.setAttribute('max', '82');
          if (isSliceContext && Number.isFinite(sliceFirstPage)) pageInputEl.setAttribute('min', String(sliceFirstPage));
          else pageInputEl.removeAttribute('max');
          document.getElementById('total').textContent = displayTotal;

          // Update source display: show filename, page and optional section
          try {
            const decoded = decodeURIComponent(file);
            const u = new URL(decoded);
            const last = u.pathname.split('/').pop() || '';
            let name = decodeURIComponent(last);
            if (isSliceContext && sliceTitle) name = sliceTitle;
            if (!isSliceContext && fileConfig && typeof fileConfig.title === 'string') name = fileConfig.title;
            const labelPage = (usePrintedForDisplay && printed) ? printed : page;
            const label = section ? `${name} — Page ${labelPage} — Section: ${section}` : `${name} — Page ${labelPage}`;
            const srcEl = document.getElementById('source');
            if (srcEl) { srcEl.textContent = label; srcEl.title = decoded; }
          } catch (_) {
            // Fallback to raw file string
            const labelPage = (usePrintedForDisplay && printed) ? printed : page;
            const label = section ? `${file} — Page ${labelPage} — Section: ${section}` : `${file} — Page ${labelPage}`;
            const srcEl = document.getElementById('source');
            if (srcEl) { srcEl.textContent = label; srcEl.title = file; }
          }

          // Update smart nav anchors
          setNavAnchors({ file, section, displayPage, total, printed, isSlice: isSliceContext, sliceBase, maxPages: (Number.isFinite(sliceMaxPages) ? sliceMaxPages : (isSliceContext ? 82 : total)), firstPage: sliceFirstPage });
        } catch (e) {
          console.error(e);
          msg.innerHTML = 'Failed to load PDF. Ensure the URL is publicly accessible.\n' +
            '<div class="msg">Tried: <a href="' + file + '">' + file + '</a></div>';
        }
      }

      function setHashPage(page) {
        const url = new URL(window.location.href);
        // Preserve existing hash params, update page
        const params = new URLSearchParams(url.hash.replace(/^#/, ''));
        params.set('page', String(page));
        url.hash = '#' + params.toString();
        history.replaceState(null, '', url);
      }

      window.addEventListener('DOMContentLoaded', () => {
        if (window.pdfjsLib) {
          pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.worker.min.js';
        }
        const { file, page, section, printed } = getParams();
        render({ file, page, section, printed });

        const leftBtn = document.getElementById('left');
        const rightBtn = document.getElementById('right');
        const pageInput = document.getElementById('page');

        // Keep input change behavior
        if (pageInput) pageInput.addEventListener('change', (e) => {
          let p = parseInt(e.target.value, 10);
          if (!Number.isFinite(p) || p < 1) p = 1;
          // Clamp for Rule Book slices to 1..82
          const gp0 = getParams();
          try {
      function fileNameFromPattern(pattern, n) {
        const p = (pattern || 'p{n}.pdf');
        return p.replace('{n}', String(n));
      }
      function regexFromPattern(pattern) {
        const p = (pattern || 'p{n}.pdf');
        const esc = p.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const re = esc.replace('\\{n\\}', '(\\d+)');
        return new RegExp(re + '$');
      }
            const dec = decodeURIComponent(gp0.file || '');
            const RB_FULL = 'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_page/Rule Book_2P V9.pdf';
            const RB_SLICE = 'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_page/slices/Rule%20Book_2P%20V9/';
            const isRBSlice = dec.startsWith(RB_SLICE);
            if (isRBSlice) p = Math.max(1, Math.min(82, p));
          } catch(_) {}
          setHashPage(p);
          const gp = getParams();
          render({ file: gp.file, page: p, section: gp.section, printed: gp.printed });
        });

        window.addEventListener('resize', () => {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => {
            const p = parseInt((document.getElementById('page')||{}).value, 10) || 1;
            const gp = getParams();
            render({ file: gp.file, page: p, section: gp.section, printed: gp.printed });
          }, 150);
        });
      });
    </script>
  </head>
  <body>
    <nav class="bar">
      <span class="brand">PDF Viewer</span>
      <span id="source" class="src" title=""></span>
      <div class="controls">
        <a id="left" class="btn" title="Previous page" href="#">◀ Previous</a>
        <label class="page">Page <input id="page" type="number" min="1" step="1" value="1" /> / <span id="total">?</span></label>
        <a id="right" class="btn" title="Next page" href="#">Next ▶</a>
      </div>
    </nav>
    <div id="msg" class="msg"></div>
    <div id="container"><canvas id="canvas"></canvas></div>
    
  </body>
  </html>
