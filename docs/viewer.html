<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Viewer</title>
    <meta name="theme-color" content="#0b0d10" media="(prefers-color-scheme: dark)">
    <meta name="theme-color" content="#f8f9fa" media="(prefers-color-scheme: light)">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
      html, body { height: 100%; margin: 0; }
      #container { display: flex; justify-content: center; padding: 10px; background: var(--bs-body-bg); }
      #canvas { max-width: 100%; width: 100%; height: auto; background: rgba(0,0,0,.2); border-radius: .25rem; }
      .src { max-width: min(60vw, 900px); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; opacity: .9; }
      .msg { padding: 16px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js" referrerpolicy="no-referrer"></script>
    <script>
      // Bootstrap theme: use dark by default; respect user/device if specified
      (function setTheme() {
        const root = document.documentElement;
        const mqDark = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
        const mqLight = window.matchMedia ? window.matchMedia('(prefers-color-scheme: light)') : null;
        // Default to dark when no explicit preference
        let theme = 'dark';
        if (mqDark && mqDark.matches) theme = 'dark';
        else if (mqLight && mqLight.matches) theme = 'light';
        root.setAttribute('data-bs-theme', theme);
        try {
          mqDark && mqDark.addEventListener('change', e => {
            root.setAttribute('data-bs-theme', e.matches ? 'dark' : (mqLight && mqLight.matches ? 'light' : 'dark'));
          });
          mqLight && mqLight.addEventListener('change', e => {
            root.setAttribute('data-bs-theme', e.matches ? 'light' : (mqDark && mqDark.matches ? 'dark' : 'dark'));
          });
        } catch (_) {}
      })();
      // Will set the worker src after pdfjsLib is available
      let currentRenderTask = null;
      let resizeTimer = null;

      function getParams() {
        const url = new URL(window.location.href);
        const file = url.searchParams.get('file');
        // Support both #page= and ?page=
        let page = parseInt(url.searchParams.get('page') || '', 10);
        if (!Number.isFinite(page)) {
          const m = (url.hash || '').match(/page=(\d+)/);
          if (m) page = parseInt(m[1], 10);
        }
        // Optional section from query or hash
        let section = url.searchParams.get('section') || '';
        if (!section) {
          const sm = (url.hash || '').match(/section=([^&#]+)/);
          if (sm) section = decodeURIComponent(sm[1]);
        }
        // Optional printed page label (for single-page slices)
        let printed = parseInt(url.searchParams.get('printed') || '', 10);
        if (!Number.isFinite(printed)) {
          const pm = (url.hash || '').match(/printed=(\d+)/);
          if (pm) printed = parseInt(pm[1], 10);
        }
        return { file, page: Number.isFinite(page) ? page : 1, section, printed: Number.isFinite(printed) ? printed : null };
      }

      function normalizeFile(file) {
        try {
          const decoded = decodeURIComponent(file);
          let out = decoded;
          // Exact file remaps from legacy folder
          const exact = new Map([
            ['https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/citation_links/Rule%20Book_2P%20V9.pdf',
             'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_page/Rule%20Book_2P%20V9.pdf'],
            ['https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/citation_links/Official%20FAQ%20for%20Game%20(no%20rules%20questions%20please)%20_%20BoardGameGeek.pdf',
             'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_title/Official%20FAQ%20for%20Game%20(no%20rules%20questions%20please)%20_%20BoardGameGeek.pdf'],
            ['https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/citation_links/Gloomhaven%20Items.pdf',
             'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_card/Gloomhaven%20Items.pdf'],
          ]);
          if (exact.has(out)) return exact.get(out);
          // Folder remaps (broad): manuals -> by_page, items -> by_card, citation_links -> by_* best-effort
          out = out.replace('/files/manuals/', '/files/by_page/');
          out = out.replace('/files/items/', '/files/by_card/');
          // citation_links best-effort: try to infer by filename
          if (out.includes('/citation_links/')) {
            if (out.endsWith('Rule%20Book_2P%20V9.pdf') || out.endsWith('Rule Book_2P V9.pdf')) {
              out = out.replace('/citation_links/', '/files/by_page/');
            } else if (out.includes('Official%20FAQ') || out.includes('Official FAQ')) {
              out = out.replace('/citation_links/', '/files/by_title/');
            } else if (out.includes('Gloomhaven%20Items.pdf') || out.includes('Gloomhaven Items.pdf')) {
              out = out.replace('/citation_links/', '/files/by_card/');
            }
          }
          return out;
        } catch (_) { /* ignore */ }
        return file;
      }

      async function render({ file, page, section, printed }) {
        const msg = document.getElementById('msg');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        if (!file) {
          msg.innerHTML = 'Missing \'file\' query param. Example: <code>viewer.html?file=' +
            encodeURIComponent('https://raw.githubusercontent.com/owner/repo/branch/path/to.pdf') + '#page=2</code>';
          return;
        }
        // Backward-compatible remapping from old citation_links/ paths
        file = normalizeFile(file);

        // Auto-slice handling for Rule Book: treat #page as printed page
        let usePrintedForDisplay = false;
        try {
          const dec = decodeURIComponent(file);
          const RULEBOOK_FULL = 'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_page/Rule Book_2P V9.pdf';
          const SLICE_BASE = 'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_page/slices/Rule%20Book_2P%20V9/';
          const isFull = (dec === RULEBOOK_FULL);
          const isSlice = dec.startsWith(SLICE_BASE);
          if ((isFull || isSlice) && Number.isFinite(page)) {
            const printedPage = printed || page; // treat incoming #page as printed page
            file = `${SLICE_BASE}p${printedPage}.pdf`;
            page = 1; // slices are single-page
            printed = printedPage;
            usePrintedForDisplay = true;
          }
        } catch (_) { /* ignore */ }
        msg.textContent = 'Loading…';
        try {
          const pdf = await pdfjsLib.getDocument({ url: file, withCredentials: false }).promise;
          const total = pdf.numPages;

          // Try to align by printed page labels if available
          let target = Math.min(Math.max(1, page), total);
          try {
            const labels = await pdf.getPageLabels();
            if (labels && labels.length === total) {
              const desired = String(page);
              // Match numeric labels, ignoring non-digits (e.g., roman numerals are skipped)
              const desiredNum = parseInt(desired, 10);
              if (Number.isFinite(desiredNum)) {
                for (let i = 0; i < labels.length; i++) {
                  const num = parseInt(String(labels[i]).replace(/[^0-9]/g, ''), 10);
                  if (num === desiredNum) { target = i + 1; break; }
                }
              }
            }
          } catch (_) { /* ignore label lookup issues */ }

          const p = await pdf.getPage(target);
          const viewport = p.getViewport({ scale: 1 });

          // Fit to device width with some margin
          const dpiScale = window.devicePixelRatio || 1;
          const targetWidthCSS = Math.min(window.innerWidth - 20, 1200);
          const scale = targetWidthCSS / viewport.width;
          const v2 = p.getViewport({ scale });

          canvas.width = Math.floor(v2.width * dpiScale);
          canvas.height = Math.floor(v2.height * dpiScale);
          canvas.style.width = Math.floor(v2.width) + 'px';
          canvas.style.height = Math.floor(v2.height) + 'px';

          // Cancel any in-flight render on the same canvas
          if (currentRenderTask && typeof currentRenderTask.cancel === 'function') {
            try { currentRenderTask.cancel(); } catch (_) {}
          }
          currentRenderTask = p.render({ canvasContext: ctx, viewport: p.getViewport({ scale: scale * dpiScale }) });
          try { await currentRenderTask.promise; } catch (_) { /* cancelled */ }
          msg.textContent = '';

          // Update controls
          const displayPage = usePrintedForDisplay && printed ? printed : target;
          document.getElementById('page').value = displayPage;
          document.getElementById('total').textContent = total;

          // Update source display: show filename, page and optional section
          try {
            const decoded = decodeURIComponent(file);
            const u = new URL(decoded);
            const last = u.pathname.split('/').pop() || '';
            const name = decodeURIComponent(last);
            const labelPage = (usePrintedForDisplay && printed) ? printed : page;
            const label = section ? `${name} — Page ${labelPage} — Section: ${section}` : `${name} — Page ${labelPage}`;
            const srcEl = document.getElementById('source');
            if (srcEl) { srcEl.textContent = label; srcEl.title = decoded; }
          } catch (_) {
            // Fallback to raw file string
            const labelPage = (usePrintedForDisplay && printed) ? printed : page;
            const label = section ? `${file} — Page ${labelPage} — Section: ${section}` : `${file} — Page ${labelPage}`;
            const srcEl = document.getElementById('source');
            if (srcEl) { srcEl.textContent = label; srcEl.title = file; }
          }
        } catch (e) {
          console.error(e);
          msg.innerHTML = 'Failed to load PDF. Ensure the URL is publicly accessible.\n' +
            '<div class="msg">Tried: <a href="' + file + '">' + file + '</a></div>';
        }
      }

      function setHashPage(page) {
        const url = new URL(window.location.href);
        // Preserve existing hash params, update page
        const params = new URLSearchParams(url.hash.replace(/^#/, ''));
        params.set('page', String(page));
        url.hash = '#' + params.toString();
        history.replaceState(null, '', url);
      }

      window.addEventListener('DOMContentLoaded', () => {
        if (window.pdfjsLib) {
          pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.worker.min.js';
        }
        const { file, page, section, printed } = getParams();
        render({ file, page, section, printed });

        const prevBtn = document.getElementById('prev');
        const nextBtn = document.getElementById('next');
        const leftBtn = document.getElementById('left');
        const rightBtn = document.getElementById('right');
        const pageInput = document.getElementById('page');

        if (prevBtn) prevBtn.addEventListener('click', () => {
          const p = Math.max(1, parseInt(pageInput.value, 10) - 1);
          pageInput.value = p;
          setHashPage(p);
          const gp = getParams();
          render({ file: gp.file, page: p, section: gp.section, printed: gp.printed });
        });
        if (nextBtn) nextBtn.addEventListener('click', () => {
          const total = parseInt(document.getElementById('total').textContent, 10) || 1;
          const p = Math.min(total, (parseInt(pageInput.value, 10) || 1) + 1);
          pageInput.value = p;
          setHashPage(p);
          const gp = getParams();
          render({ file: gp.file, page: p, section: gp.section, printed: gp.printed });
        });
        // Left/Right page helpers (same as prev/next but labeled for book layout)
        if (leftBtn) leftBtn.addEventListener('click', () => {
          const p = Math.max(1, (parseInt(pageInput.value, 10) || 1) - 1);
          if (p === parseInt(pageInput.value, 10)) return; // no change
          pageInput.value = p; setHashPage(p);
          const gp = getParams();
          render({ file: gp.file, page: p, section: gp.section, printed: gp.printed });
        });
        if (rightBtn) rightBtn.addEventListener('click', () => {
          const total = parseInt(document.getElementById('total').textContent, 10) || 1;
          const p = Math.min(total, (parseInt(pageInput.value, 10) || 1) + 1);
          if (p === parseInt(pageInput.value, 10)) return; // no change
          pageInput.value = p; setHashPage(p);
          const gp = getParams();
          render({ file: gp.file, page: p, section: gp.section, printed: gp.printed });
        });
        if (pageInput) pageInput.addEventListener('change', (e) => {
          let p = parseInt(e.target.value, 10);
          if (!Number.isFinite(p) || p < 1) p = 1;
          setHashPage(p);
          const gp = getParams();
          render({ file: gp.file, page: p, section: gp.section, printed: gp.printed });
        });

        window.addEventListener('resize', () => {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => {
            const p = parseInt((document.getElementById('page')||{}).value, 10) || 1;
            const gp = getParams();
            render({ file: gp.file, page: p, section: gp.section, printed: gp.printed });
          }, 150);
        });
      });
    </script>
  </head>
  <body class="bg-body text-body">
    <nav class="navbar navbar-expand-lg border-bottom bg-body-tertiary sticky-top">
      <div class="container-fluid gap-2">
        <span class="navbar-brand">PDF Viewer</span>
        <span id="source" class="src me-auto" title=""></span>
        <div class="d-flex align-items-center gap-2">
          <div class="btn-group" role="group" aria-label="Page navigation">
            <button id="left" class="btn btn-outline-secondary" title="Left page">◀ Left</button>
            <button id="prev" class="btn btn-outline-secondary" title="Previous page">◀</button>
            <div class="input-group" style="width: 140px;">
              <span class="input-group-text">Page</span>
              <input id="page" class="form-control" type="number" min="1" step="1" value="1" />
              <span class="input-group-text">/ <span id="total">?</span></span>
            </div>
            <button id="next" class="btn btn-outline-secondary" title="Next page">▶</button>
            <button id="right" class="btn btn-outline-secondary" title="Right page">Right ▶</button>
          </div>
        </div>
      </div>
    </nav>
    <div id="msg" class="msg"></div>
    <div id="container"><canvas id="canvas"></canvas></div>
    
  </body>
  </html>
