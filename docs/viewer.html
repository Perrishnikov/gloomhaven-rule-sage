<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Viewer</title>
    <style>
      html, body { height: 100%; margin: 0; background: #111; color: #eee; }
      .bar { display: flex; gap: 12px; align-items: center; padding: 10px; background: #1b1b1b; position: sticky; top: 0; z-index: 1; }
      .bar input { width: 56px; }
      .src { max-width: min(70vw, 900px); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; opacity: 0.9; }
      #container { display: flex; justify-content: center; padding: 10px; }
      #canvas { max-width: 100%; width: 100%; height: auto; background: #222; }
      .msg { padding: 16px; }
      a { color: #9cf; }
      .spacer { flex: 1; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js" referrerpolicy="no-referrer"></script>
    <script>
      // Will set the worker src after pdfjsLib is available
      let currentRenderTask = null;
      let resizeTimer = null;

      function getParams() {
        const url = new URL(window.location.href);
        const file = url.searchParams.get('file');
        // Support both #page= and ?page=
        let page = parseInt(url.searchParams.get('page') || '', 10);
        if (!Number.isFinite(page)) {
          const m = (url.hash || '').match(/page=(\d+)/);
          if (m) page = parseInt(m[1], 10);
        }
        // Optional section from query or hash
        let section = url.searchParams.get('section') || '';
        if (!section) {
          const sm = (url.hash || '').match(/section=([^&#]+)/);
          if (sm) section = decodeURIComponent(sm[1]);
        }
        return { file, page: Number.isFinite(page) ? page : 1, section };
      }

      function normalizeFile(file) {
        try {
          const decoded = decodeURIComponent(file);
          const mappings = [
            {
              from: 'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/citation_links/Rule%20Book_2P%20V9.pdf',
              to:   'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_page/Rule%20Book_2P%20V9.pdf',
            },
            {
              from: 'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/citation_links/Official%20FAQ%20for%20Game%20(no%20rules%20questions%20please)%20_%20BoardGameGeek.pdf',
              to:   'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_title/Official%20FAQ%20for%20Game%20(no%20rules%20questions%20please)%20_%20BoardGameGeek.pdf',
            },
            {
              from: 'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/citation_links/Gloomhaven%20Items.pdf',
              to:   'https://raw.githubusercontent.com/Perrishnikov/gloomhaven-rule-sage/main/files/by_card/Gloomhaven%20Items.pdf',
            },
          ];
          for (const m of mappings) {
            if (decoded === m.from) return m.to;
          }
        } catch (_) { /* ignore */ }
        return file;
      }

      async function render({ file, page, section }) {
        const msg = document.getElementById('msg');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        if (!file) {
          msg.innerHTML = 'Missing \'file\' query param. Example: <code>viewer.html?file=' +
            encodeURIComponent('https://raw.githubusercontent.com/owner/repo/branch/path/to.pdf') + '#page=2</code>';
          return;
        }
        // Backward-compatible remapping from old citation_links/ paths
        file = normalizeFile(file);
        msg.textContent = 'Loading…';
        try {
          const pdf = await pdfjsLib.getDocument({ url: file, withCredentials: false }).promise;
          const total = pdf.numPages;

          // Try to align by printed page labels if available
          let target = Math.min(Math.max(1, page), total);
          try {
            const labels = await pdf.getPageLabels();
            if (labels && labels.length === total) {
              const desired = String(page);
              // Match numeric labels, ignoring non-digits (e.g., roman numerals are skipped)
              const desiredNum = parseInt(desired, 10);
              if (Number.isFinite(desiredNum)) {
                for (let i = 0; i < labels.length; i++) {
                  const num = parseInt(String(labels[i]).replace(/[^0-9]/g, ''), 10);
                  if (num === desiredNum) { target = i + 1; break; }
                }
              }
            }
          } catch (_) { /* ignore label lookup issues */ }

          const p = await pdf.getPage(target);
          const viewport = p.getViewport({ scale: 1 });

          // Fit to device width with some margin
          const dpiScale = window.devicePixelRatio || 1;
          const targetWidthCSS = Math.min(window.innerWidth - 20, 1200);
          const scale = targetWidthCSS / viewport.width;
          const v2 = p.getViewport({ scale });

          canvas.width = Math.floor(v2.width * dpiScale);
          canvas.height = Math.floor(v2.height * dpiScale);
          canvas.style.width = Math.floor(v2.width) + 'px';
          canvas.style.height = Math.floor(v2.height) + 'px';

          // Cancel any in-flight render on the same canvas
          if (currentRenderTask && typeof currentRenderTask.cancel === 'function') {
            try { currentRenderTask.cancel(); } catch (_) {}
          }
          currentRenderTask = p.render({ canvasContext: ctx, viewport: p.getViewport({ scale: scale * dpiScale }) });
          try { await currentRenderTask.promise; } catch (_) { /* cancelled */ }
          msg.textContent = '';

          // Update controls
          document.getElementById('page').value = target;
          document.getElementById('total').textContent = total;

          // Update source display: show filename, page and optional section
          try {
            const decoded = decodeURIComponent(file);
            const u = new URL(decoded);
            const last = u.pathname.split('/').pop() || '';
            const name = decodeURIComponent(last);
            const label = section ? `${name} — Page ${page} — Section: ${section}` : `${name} — Page ${page}`;
            const srcEl = document.getElementById('source');
            if (srcEl) { srcEl.textContent = label; srcEl.title = decoded; }
          } catch (_) {
            // Fallback to raw file string
            const label = section ? `${file} — Page ${page} — Section: ${section}` : `${file} — Page ${page}`;
            const srcEl = document.getElementById('source');
            if (srcEl) { srcEl.textContent = label; srcEl.title = file; }
          }
        } catch (e) {
          console.error(e);
          msg.innerHTML = 'Failed to load PDF. Ensure the URL is publicly accessible.\n' +
            '<div class="msg">Tried: <a href="' + file + '">' + file + '</a></div>';
        }
      }

      function setHashPage(page) {
        const url = new URL(window.location.href);
        url.hash = '#page=' + page;
        history.replaceState(null, '', url);
      }

      window.addEventListener('DOMContentLoaded', () => {
        if (window.pdfjsLib) {
          pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.worker.min.js';
        }
        const { file, page, section } = getParams();
        render({ file, page, section });

        const prevBtn = document.getElementById('prev');
        const nextBtn = document.getElementById('next');
        const pageInput = document.getElementById('page');

        if (prevBtn) prevBtn.addEventListener('click', () => {
          const p = Math.max(1, parseInt(pageInput.value, 10) - 1);
          pageInput.value = p;
          setHashPage(p);
          const gp = getParams();
          render({ file: gp.file, page: p, section: gp.section });
        });
        if (nextBtn) nextBtn.addEventListener('click', () => {
          const total = parseInt(document.getElementById('total').textContent, 10) || 1;
          const p = Math.min(total, (parseInt(pageInput.value, 10) || 1) + 1);
          pageInput.value = p;
          setHashPage(p);
          const gp = getParams();
          render({ file: gp.file, page: p, section: gp.section });
        });
        if (pageInput) pageInput.addEventListener('change', (e) => {
          let p = parseInt(e.target.value, 10);
          if (!Number.isFinite(p) || p < 1) p = 1;
          setHashPage(p);
          const gp = getParams();
          render({ file: gp.file, page: p, section: gp.section });
        });

        window.addEventListener('resize', () => {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => {
            const p = parseInt((document.getElementById('page')||{}).value, 10) || 1;
            const gp = getParams();
            render({ file: gp.file, page: p, section: gp.section });
          }, 150);
        });
      });
    </script>
  </head>
  <body>
    <div class="bar">
      <strong style="white-space:nowrap;">PDF Viewer</strong>
      <span id="source" class="src" title=""></span>
      <span class="spacer"></span>
      <button id="prev" title="Previous Page">◀</button>
      <label>Page <input id="page" type="number" min="1" step="1" value="1" /></label>
      <span>/ <span id="total">?</span></span>
    </div>
    <div id="msg" class="msg"></div>
    <div id="container"><canvas id="canvas"></canvas></div>
    
  </body>
  </html>
